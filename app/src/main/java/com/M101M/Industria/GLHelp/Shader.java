package com.M101M.Industria.GLHelp;

import android.opengl.*;
import com.M101M.Industria.*;
import com.M101M.Industria.Utils.*;

public class Shader
{
	public static void init()
	{
		int[] handle = GLM.genBuffers(2);

		matHandle = handle[0];
		float[] mat = new float[materials.length * 4];
		for (int i=0; i < materials.length; i++)
			System.arraycopy(Utils.hexToArray(materials[i]), 0, mat, i * 4, 4);
		gl.glBindBuffer(GLES20.GL_ARRAY_BUFFER, matHandle);
		gl.glBufferData(GLES30.GL_ARRAY_BUFFER, mat.length * 4, Utils.toFloatBuffer(mat), GLES30.GL_STATIC_DRAW);
		
		gl.glBindBuffer(GLES20.GL_ARRAY_BUFFER, 0);
		
		programs = new int[10];
		
		programs[BLOCK] = GLM.createProgram(
			GLM.loadShader(GLES20.GL_VERTEX_SHADER, blockVert),
			GLM.loadShader(GLES20.GL_FRAGMENT_SHADER, BlockFrag)
		);
		
		programs[PLANE] = GLM.createProgram(
			GLM.loadShader(GLES20.GL_VERTEX_SHADER, planeVert),
			GLM.loadShader(GLES20.GL_FRAGMENT_SHADER, planeFrag)
		);
		
		programs[RECTANGLE] = GLM.createProgram(
			GLM.loadShader(GLES20.GL_VERTEX_SHADER, rectangleVert),
			GLM.loadShader(GLES20.GL_FRAGMENT_SHADER, rectangleFrag)
		);
		
		programs[TEXT] = GLM.createProgram(
			GLM.loadShader(GLES20.GL_VERTEX_SHADER, textVert),
			GLM.loadShader(GLES20.GL_FRAGMENT_SHADER, textFrag)
		);
	}
	public static void use(int type)
	{
		program = programs[type];
		gl.glUseProgram(program);
	}
	public static int getUniform(String name)
	{
		return gl.glGetUniformLocation(program, name);
	}
	public static int getAttribute(String name)
	{
		int ret = gl.glGetAttribLocation(program, name);
		gl.glEnableVertexAttribArray(ret);
		return ret;
	}
	
	public static final int BLOCK=0, PLANE=1, RECTANGLE=2, TEXT=3;
	private static int programs[], program;
	private static final String[] blockVert = {
		"uniform mat4 mvpMat;",
		"uniform vec4 position, selected;",
		"uniform int type;",
		"attribute vec4 vertex;",
		"attribute vec4 material;",
		"varying vec4 pos;",
		"varying float sel;",
		"varying vec4 color;",
		"void main() {",
		"		gl_Position = mvpMat * (position + vertex);",
		"		color = material; pos = vertex; sel = (selected.x == position.x && selected.y == position.y && selected.z == position.z ? 1.0 : 0.0);",
		"}"
	}, BlockFrag = {
		"uniform int tick,type;",
		"varying vec4 pos;",
		"varying float sel;",
		"varying vec4 color;",
		"void set(float f, vec4 col) {",
		"		gl_FragColor = f*col + (1.0-f)*vec4(vec3(1,1,1)-col.rgb,1);",
		"}",
		"void main() {",
		"		float f = 1.0;",
		"		if (sel == 1.0)",
		"				f = sin(6.2832*float(tick-tick/" + (1300 / Game.tps) + "*" + (1300 / Game.tps) + ")/" + (1300 / Game.tps) + ".0)/2.0+0.5;",
		"		set(f, color);",
		"		if (type == " + Type.cable + " || type == " + Type.cablePow + ") {",
		"       float d = 0.15, s = -1.0, l = 0.0;",
		"				if (abs(pos.x-0.5) < d) { s = pos.x; l = (fract(pos.y) == 0.0 ? pos.z : pos.y); }",
		"				if (abs(pos.y-0.5) < d) { s = pos.y; l = (fract(pos.z) == 0.0 ? pos.x : pos.z); }",
		"				if (abs(pos.z-0.5) < d) { s = pos.z; l = (fract(pos.x) == 0.0 ? pos.y : pos.x); }",
		"				if (s == -1.0 || (abs(s-0.5) < 0.027 && abs(l-0.5) >= d)) {",
		"						set(f, vec4(0,0,0,1));",
		"						return;",
		"				}",
		"				if (type != " + Type.cablePow + " || abs(l-0.5) < d)",
		"						return;",
		"				s -= 0.5-d;",
		"				float c = 0.28*sin(6.28319*((s<d ? l : 1.0-l) + float(tick)/" + (600 / Game.tps) + ".0));",
		"				set(f, color + vec4(c,c,c,0));",
		"		}",
		"}"
	}, planeVert = {
		"uniform mat4 mvpMat; uniform vec4 position;",
		"attribute vec4 vertex;",
		"varying vec4 pos;",
		"void main() {",
		"		gl_Position = mvpMat * (position + vertex);",
		"		pos = vertex + position;",
		"}"
	}, planeFrag = {
		"varying vec4 pos;",
		"void main() {",
		"		vec4 f = fract(pos);",
		"		if (f.x < 0.02 || f.x > 0.98 || f.z < 0.02 || f.z > 0.98)",
		"				gl_FragColor = vec4(0,0,0,1);",
		"		else gl_FragColor = vec4(0.5,0.5,0.5,1);",
		"}"
	}, rectangleVert = {
		"uniform mat4 mvpMat;",
		"attribute vec4 vertex;",
		"void main() {",
		"		gl_Position = mvpMat * vertex;",
		"}"
	}, rectangleFrag = {
		"uniform vec4 color;",
		"void main() {",
		"		gl_FragColor = color;",
		"}"
	}, textVert = {
		"uniform mat4 mvpMat;",
		"attribute vec4 vertex, uv;",
		"varying vec2 pos;",
		"void main() {",
		"		gl_Position = mvpMat * vertex;",
		"		pos = uv.xy;",
		"}"
	}, textFrag = {
		"uniform vec4 color;",
		"uniform int text[6];",
		"varying vec2 pos;",
		"void main() {",
		"		int i = text[int(pos.x)], n = 1;",
		"		for (int j=0; j<int(pos.y); j++) n *= 2;",
		"		if (i/n - int(i/n/2)*2 == 1)",
		"				gl_FragColor = color;",
		"		else",
		"				gl_FragColor = vec4(0,0,0,0);",
		"}"
	};

	public static int matHandle, matStride=32 * 4;
	public static final int[] materials = {
		0x888888,0x888888,0x00ff00,0x888888,0x00ff00,0x888888,0x00ff00,0x00ff00,
		0x888888,0x888888,0x888888,0x888888,0x888888,0x888888,0x888888,0x888888,
		0xcc2200,0xcc2200,0xcc2200,0xcc2200,0xcc2200,0xcc2200,0xcc2200,0xcc2200,
		0x008800,0x008800,0x008800,0x008800,0x008800,0x008800,0x008800,0x008800,
		0x00dd00,0x00dd00,0x00dd00,0x00dd00,0x00dd00,0x00dd00,0x00dd00,0x00dd00
	};

	public static int letterHandle, letterStride=6;
	public static final int[] letters = {
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // space
		0x00, 0x00, 0x00, 0x5f, 0x00, 0x00,   // !
		0x00, 0x00, 0x07, 0x00, 0x07, 0x00,   // "
		0x00, 0x14, 0x7f, 0x14, 0x7f, 0x14,   // #
		0x00, 0x24, 0x2a, 0x7f, 0x2a, 0x12,   // $
		0x00, 0x23, 0x13, 0x08, 0x64, 0x62,   // %
		0x00, 0x36, 0x49, 0x55, 0x22, 0x50,   // &
		0x00, 0x00, 0x05, 0x03, 0x00, 0x00,   // '
		0x00, 0x00, 0x1c, 0x22, 0x41, 0x00,   // (
		0x00, 0x00, 0x41, 0x22, 0x1c, 0x00,   // )
		0x00, 0x14, 0x08, 0x3E, 0x08, 0x14,   // *
		0x00, 0x08, 0x08, 0x3E, 0x08, 0x08,   // +
		0x00, 0x00, 0x00, 0xA0, 0x60, 0x00,   // ,
		0x00, 0x08, 0x08, 0x08, 0x08, 0x08,   // -
		0x00, 0x00, 0x60, 0x60, 0x00, 0x00,   // .
		0x00, 0x20, 0x10, 0x08, 0x04, 0x02,   // /

		0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E,   // 0  16
		0x00, 0x00, 0x42, 0x7F, 0x40, 0x00,   // 1
		0x00, 0x42, 0x61, 0x51, 0x49, 0x46,   // 2
		0x00, 0x21, 0x41, 0x45, 0x4B, 0x31,   // 3
		0x00, 0x18, 0x14, 0x12, 0x7F, 0x10,   // 4
		0x00, 0x27, 0x45, 0x45, 0x45, 0x39,   // 5
		0x00, 0x3C, 0x4A, 0x49, 0x49, 0x30,   // 6
		0x00, 0x01, 0x71, 0x09, 0x05, 0x03,   // 7
		0x00, 0x36, 0x49, 0x49, 0x49, 0x36,   // 8
		0x00, 0x06, 0x49, 0x49, 0x29, 0x1E,   // 9
		0x00, 0x00, 0x36, 0x36, 0x00, 0x00,   // :
		0x00, 0x00, 0x56, 0x36, 0x00, 0x00,   // ;
		0x00, 0x08, 0x14, 0x22, 0x41, 0x00,   // <
		0x00, 0x14, 0x14, 0x14, 0x14, 0x14,   // =
		0x00, 0x00, 0x41, 0x22, 0x14, 0x08,   // >
		0x00, 0x02, 0x01, 0x51, 0x09, 0x06,   // ?

		0x00, 0x32, 0x49, 0x59, 0x51, 0x3E,   // @  32
		0x00, 0x7C, 0x12, 0x11, 0x12, 0x7C,   // A
		0x00, 0x7F, 0x49, 0x49, 0x49, 0x36,   // B
		0x00, 0x3E, 0x41, 0x41, 0x41, 0x22,   // C
		0x00, 0x7F, 0x41, 0x41, 0x22, 0x1C,   // D
		0x00, 0x7F, 0x49, 0x49, 0x49, 0x41,   // E
		0x00, 0x7F, 0x09, 0x09, 0x09, 0x01,   // F
		0x00, 0x3E, 0x41, 0x49, 0x49, 0x7A,   // G
		0x00, 0x7F, 0x08, 0x08, 0x08, 0x7F,   // H
		0x00, 0x00, 0x41, 0x7F, 0x41, 0x00,   // I
		0x00, 0x20, 0x40, 0x41, 0x3F, 0x01,   // J
		0x00, 0x7F, 0x08, 0x14, 0x22, 0x41,   // K
		0x00, 0x7F, 0x40, 0x40, 0x40, 0x40,   // L
		0x00, 0x7F, 0x02, 0x0C, 0x02, 0x7F,   // M
		0x00, 0x7F, 0x04, 0x08, 0x10, 0x7F,   // N
		0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E,   // O
		
		0x00, 0x7F, 0x09, 0x09, 0x09, 0x06,   // P  48
		0x00, 0x3E, 0x41, 0x51, 0x21, 0x5E,   // Q
		0x00, 0x7F, 0x09, 0x19, 0x29, 0x46,   // R
		0x00, 0x46, 0x49, 0x49, 0x49, 0x31,   // S
		0x00, 0x01, 0x01, 0x7F, 0x01, 0x01,   // T
		0x00, 0x3F, 0x40, 0x40, 0x40, 0x3F,   // U
		0x00, 0x1F, 0x20, 0x40, 0x20, 0x1F,   // V
		0x00, 0x3F, 0x40, 0x38, 0x40, 0x3F,   // W
		0x00, 0x63, 0x14, 0x08, 0x14, 0x63,   // X
		0x00, 0x07, 0x08, 0x70, 0x08, 0x07,   // Y
		0x00, 0x61, 0x51, 0x49, 0x45, 0x43,   // Z
		0x00, 0x00, 0x7F, 0x41, 0x41, 0x00,   // [
		0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,   // \ -> Checker pattern
		0x00, 0x00, 0x41, 0x41, 0x7F, 0x00,   // ]
		0x00, 0x04, 0x02, 0x01, 0x02, 0x04,   // ^
		0x00, 0x40, 0x40, 0x40, 0x40, 0x40,   // _

		0x00, 0x00, 0x03, 0x05, 0x00, 0x00,   // `  64
		0x00, 0x20, 0x54, 0x54, 0x54, 0x78,   // a
		0x00, 0x7F, 0x48, 0x44, 0x44, 0x38,   // b
		0x00, 0x38, 0x44, 0x44, 0x44, 0x20,   // c
		0x00, 0x38, 0x44, 0x44, 0x48, 0x7F,   // d
		0x00, 0x38, 0x54, 0x54, 0x54, 0x18,   // e
		0x00, 0x08, 0x7E, 0x09, 0x01, 0x02,   // f
		0x00, 0x18, 0xA4, 0xA4, 0xA4, 0x7C,   // g
		0x00, 0x7F, 0x08, 0x04, 0x04, 0x78,   // h
		0x00, 0x00, 0x44, 0x7D, 0x40, 0x00,   // i
		0x00, 0x40, 0x80, 0x84, 0x7D, 0x00,   // j
		0x00, 0x7F, 0x10, 0x28, 0x44, 0x00,   // k
		0x00, 0x00, 0x41, 0x7F, 0x40, 0x00,   // l
		0x00, 0x7C, 0x04, 0x18, 0x04, 0x78,   // m
		0x00, 0x7C, 0x08, 0x04, 0x04, 0x78,   // n
		0x00, 0x38, 0x44, 0x44, 0x44, 0x38,   // o
		
		0x00, 0xFC, 0x24, 0x24, 0x24, 0x18,   // p  80
		0x00, 0x18, 0x24, 0x24, 0x18, 0xFC,   // q
		0x00, 0x7C, 0x08, 0x04, 0x04, 0x08,   // r
		0x00, 0x48, 0x54, 0x54, 0x54, 0x20,   // s
		0x00, 0x04, 0x3F, 0x44, 0x40, 0x20,   // t
		0x00, 0x3C, 0x40, 0x40, 0x20, 0x7C,   // u
		0x00, 0x1C, 0x20, 0x40, 0x20, 0x1C,   // v
		0x00, 0x3C, 0x40, 0x30, 0x40, 0x3C,   // w
		0x00, 0x44, 0x28, 0x10, 0x28, 0x44,   // x
		0x00, 0x1C, 0xA0, 0xA0, 0xA0, 0x7C,   // y
		0x00, 0x44, 0x64, 0x54, 0x4C, 0x44,   // z
		0x00, 0x00, 0x10, 0x7C, 0x82, 0x00,   // {
		0x00, 0x00, 0x00, 0xFF, 0x00, 0x00,   // |
		0x00, 0x00, 0x82, 0x7C, 0x10, 0x00,   // }
		0x00, 0x00, 0x06, 0x09, 0x09, 0x06,   // ~ -> °
		0x00, 0x20, 0x55, 0x54, 0x55, 0x78,   // ä
		
		0x00, 0x38, 0x45, 0x44, 0x45, 0x38,   // ö
		0x00, 0x3C, 0x41, 0x40, 0x21, 0x7C,   // ü
		0x00, 0x79, 0x14, 0x14, 0x14, 0x79,   // Ä
		0x00, 0x39, 0x44, 0x44, 0x44, 0x39,   // Ö
		0x00, 0x3D, 0x40, 0x40, 0x40, 0x3D,   // Ü
	};
}
